import os
import subprocess
from typing import Mapping

from oncall.lib.logging import logger

EXCLUDED_DIRS = {
    "venv",
    ".venv",
    "site-packages",
    "__pycache__",
    "node_modules",
    ".git",
    "api_clients",
    "__test__",
    "rapidsnark",
    "test",
    "graph-node",
    "doc-images",
    "fixtures",
    "circuit-artifacts",
    ".yarn",
    ".changeset",
    ".github",
    "subgraph",
    "types",
    "autogenerated",
    "dist",
    "packages",
    "tools",
    "bindings",
}

EXCLUDED_EXTENSIONS = (".json",)


def is_excluded(path):
    return any(excluded in path.split(os.sep) for excluded in EXCLUDED_DIRS)


def collect_files(directory, allowed_extensions, repo_root):
    file_tree = []
    path_to_source_code = {}
    for root, dirs, files in os.walk(directory):
        # Skip excluded directories
        dirs[:] = [d for d in dirs if not is_excluded(os.path.join(root, d))]
        for file in files:
            if file.endswith(EXCLUDED_EXTENSIONS):
                continue
            if file.endswith(allowed_extensions):
                file_path = os.path.join(root, file)
                if is_excluded(file_path):
                    continue
                rel_path = os.path.relpath(file_path, repo_root)
                file_tree.append(rel_path)
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        path_to_source_code[rel_path] = f.read()
                except Exception as e:
                    path_to_source_code[rel_path] = f"Error reading file: {e}"
    return file_tree, path_to_source_code


# TODO: replace with tree command or glob
def generate_tree_string(file_paths):
    """
    Given a list of file paths, generate a string that represents the file tree structure.
    """
    tree = {}
    # Build nested dictionary from file paths
    for path in file_paths:
        parts = path.split(os.sep)
        subtree = tree
        for part in parts:
            subtree = subtree.setdefault(part, {})

    def tree_to_str(subtree, prefix=""):
        lines = []
        keys = sorted(subtree.keys())
        for i, key in enumerate(keys):
            connector = "└── " if i == len(keys) - 1 else "├── "
            lines.append(prefix + connector + key)
            if subtree[key]:
                extension = "    " if i == len(keys) - 1 else "│   "
                lines.extend(tree_to_str(subtree[key], prefix + extension))
        return lines

    return "\n".join(tree_to_str(tree))


def clone_repository(repo_url, clone_dir, branch=None):
    logger.info(f"Cloning repository {repo_url} into {clone_dir}...")
    cmd = ["git", "clone"]
    if branch:
        cmd += ["--branch", branch]
    cmd += [repo_url, clone_dir]
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        error_msg = f"Git clone failed: {result.stderr}"
        logger.error(error_msg)
        raise Exception(error_msg)
    logger.info("Repository clone completed.")


def print_source_files(file_map: Mapping[str, str]):
    """
    Nicely prints each file's path and its source code from the given file map.

    :param file_map: A dictionary where keys are file paths and values are source code.
    """
    separator = "=" * 80
    for file_path, source_code in file_map.items():
        print(f"\n{separator}")
        print(f"File: {file_path}")
        print(f"{separator}\n")
        print(source_code)
        print("\n")

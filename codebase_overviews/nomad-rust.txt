Below is the comprehensive system architecture document for Nomad’s cross‐chain bridge protocol. This document provides a holistic view of the system by detailing the major modules/directories in the repository, their responsibilities, and how they interact to implement the optimistic security model. The file tree–style breakdown below is organized by top‐level directory, with descriptions that allow you to navigate the codebase and understand where to look when addressing issues or extending functionality.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n# Nomad Cross‑Chain Bridge Protocol: System Architecture\n\nNomad is a cross‑chain bridge protocol that leverages an optimistic security model. In this system, a trusted updater attests to updates; a relayer forwards these updates to the destination chain; following a fraud period, a watcher monitors and flags any improper updates; and finally, a processor proves that messages are included in an accumulated Merkle tree and processes them as on‑chain transactions. For testing and demonstration purposes, a “kathy” agent simulates messaging with chat features. The architecture is organized as independent modules that together provide configuration, cryptographic proofs, chain integration, base agent infrastructure, and test utilities.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n## 1. Overview of Core System Components\n\n- **Configuration & Types**  \n  Centralizes all deployment, network, agent, and contract settings. It also provides WASM interfaces for type‑safe front‑end interactions.  \n- **Nomad‑Types**  \n  Provides shared type definitions, custom error handling, and deserialization macros. These types standardize identifiers, numeric formats, and proxy configurations.\n- **Nomad‑Test**  \n  Offers mocks and testing utilities to simulate on‑chain events and contract interactions, enabling robust testing of the protocol without live blockchain connections.\n- **Nomad‑Core**  \n  Implements the low‑level primitives for on‑chain communication, state management, cryptographic processing (including Merkle proofs), database persistence, AWS integrations, and test vector generation.\n- **Agents**  \n  A set of standalone runtime services (binaries) responsible for discrete parts of the protocol:\n  • The **Updater** creates and signs updates to the home chain.\n  • The **Relayer** scans for attested updates and forwards them to the replica.\n  • The **Processor** fetches the next message, generates inclusion proofs using the accumulator’s Merkle tree, and processes the message on‑chain.\n  • The **Watcher** monitors for fraud (e.g. double updates) by inspecting update history and chain state.\n  • The **Kathy** agent (for demos) sends chatty messages into the system.\n- **Nomad‑Base**  \n  Provides a foundational framework and shared components for building and running agents, including abstractions for agent behavior, persistent storage, Prometheus metrics, contract syncing, and error handling.\n- **Accumulator**  \n  Implements Merkle tree logic (full and lightweight variants) used for creating and verifying inclusion proofs of messages or other data in an off‑chain accumulator. The module also provides WebAssembly bindings.\n- **Chains**  \n  Contains two separate modules for blockchain integration:\n  • **nomad‑ethereum:** Interfaces with Ethereum‑compatible chains using ethers and generated smart contract bindings.\n  • **nomad‑substrate:** Supports Substrate‑based chains using the Subxt ecosystem, along with SCALE encoding/decoding support.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n## 2. Repository Directory Breakdown\n\nBelow is a file tree–style layout with descriptions for each major module or directory.\n\n### configuration\n```\nconfiguration/\n├── build.rs\n│   • Build‐time script that fetches remote JSON config files, generates WASM bindings\n│     (injecting TypeScript definitions), and sets build directives.\n├── data/\n│   ├── definitions.ts\n│   │   • TypeScript interfaces for Nomad configuration types (AppConfig, AgentConfig, etc.).\n│   └── types.rs\n│       • Externally declared types used with wasm_bindgen, ensuring consistency between Rust and JS/TS.\n└── src/\n    ├── agent/\n    │   • Contains agent‑specific configuration types.\n    │   ├── kathy.rs       – Configuration for the Kathy agent (chat generation settings).\n    │   ├── logging.rs     – Standard logging types (levels, style, etc.) for all agents.\n    │   ├── mod.rs         – Aggregator of all agent configs.\n    │   ├── processor.rs   – Processor-specific settings (allowed/denied message filtering, S3 proofs).\n    │   ├── relayer.rs     – Basic configuration for the Relayer.\n    │   ├── updater.rs     – Settings for the Updater agent.\n    │   └── watcher.rs     – Watcher-specific parameters for detecting fraudulent updates.\n    ├── bridge.rs\n    │   • Configuration for bridge contracts (deployment info, proxy addresses, accountant configuration).\n    ├── builtin.rs\n    │   • Embeds preset configuration files (test, development, staging, production) using lazy deserialization.\n    ├── chains/\n    │   • Chain‑specific configuration.\n    │   ├── ethereum/\n    │   │   ├── mod.rs       – Re‑exports Ethereum config.\n    │   │   └── submitter/\n    │   │       ├── gelato.rs  – Configures Gelato relay submission details.\n    │   │       └── mod.rs     – Transaction submission configurations.\n    │   ├── mod.rs\n    │   └── substrate/\n    │       └── mod.rs       – Substrate‑specific configuration types.\n    ├── core.rs\n    │   • Defines Nomad’s core deployment configuration for Home and Replica contracts.\n    ├── gas/\n    │   ├── defaults.rs    – Default gas configuration constants.\n    │   └── mod.rs         – Types and custom deserialization logic for gas limits.\n    ├── lib.rs\n    │   • Main entry point that re‑exports all sub‑modules; defines the top‑level NomadConfig.\n    ├── network.rs\n    │   • Data types for network and domain mapping, including governance and contract specs.\n    ├── secrets.rs\n    │   • Defines AgentSecrets (RPC endpoints, TX keys, attestation configurations), loadable from JSON or env.\n    ├── traits/\n    │   ├── env.rs         – Trait for allowing configuration overrides via environment variables.\n    │   └── mod.rs         – Re‑exports helper traits.\n    ├── utils.rs\n    │   • Miscellaneous helpers (e.g. fetching network settings from env with defaults).\n    └── wasm/\n        ├── bindings.rs   – Exports config functions (getBuiltin, validateConfig, etc.) via wasm_bindgen.\n        ├── mod.rs        – Aggregates WASM exports.\n        └── types.ts      – Auto‐generated TypeScript types for Nomad configuration.\n```\n*Overall Role:* Centralizes the configuration for all aspects of the cross‑chain bridge—from contract deployments and network settings to per‑agent parameters—ensuring that both back‑end services, CLI tools, and front‑end clients have a consistent view of the system.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### nomad-types\n```\nnomad-types/\n└── src/\n    ├── error.rs\n    │   • Defines NomadTypeError (e.g. AddressConversionError) used across type conversion operations.\n    ├── lib.rs\n    │   • Main library file re‑exporting error and macros.\n    │   • Defines shared constructs such as HexString, NomadIdentifier (with conversion helpers), NameOrDomain, NomadLocator, and Proxy.\n    └── macros.rs\n        • Declares macros (like impl_deser_nomad_number) that enable flexible deserialization of numeric types (from strings or integer literals).\n```\n*Overall Role:* Provides unified, strongly‑typed representations for identifiers, addresses, and numeric values. This module ensures data consistency across all components (configuration, agents, chain connectors).\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### nomad-test\n```\nnomad-test/\n└── src/\n    ├── lib.rs\n    │   • Top‑level test library file that re‑exports mocks and test utilities.\n    ├── test_utils.rs\n    │   • Helpers to setup test databases, mock HTTP responses, coordinate env variable loading, and cleanup.\n    └── mocks/\n        ├── mod.rs\n        │   • Aggregator for mocks; re‑exports mocks for Home, Replica, Indexer, and XApp (connection manager).\n        ├── home.rs\n        │   • Mock implementation of the Home contract (dispatching, message retrieval).\n        ├── replica.rs\n        │   • Simulated Replica contract with methods to mimic proof, process, and state queries.\n        ├── indexer.rs\n        │   • Provides a mock Indexer for retrieving sorted updates and messages.\n        └── xapp.rs\n            • Mocks the Connection Manager functionality (replica enrollment, watcher permissions, etc.).\n```\n*Overall Role:* Enables testing and integration without requiring live chains. Mocks and helpers here simulate on‑chain behavior so that agents and components can be validated in isolation.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### nomad-core\n```\nnomad-core/\n├── bin/\n│   ├── lib_test_output.rs\n│   │   • Generates JSON test vectors for signed updates and other outputs.\n│   ├── proof_output.rs\n│   │   • Outputs sample Merkle proofs in JSON format.\n│   └── utils_test_output.rs\n│       • Produces test vectors for home domain hashes and destination–nonce combinations.\n├── src/\n│   ├── aws.rs\n│   │   • Provides AWS integration (KMS, secret retrieval) using rusoto.\n│   ├── chain.rs\n│   │   • Defines basic on‑chain primitives (Address, Balance, ContractLocator) and the Chain trait.\n│   ├── db/\n│   │   ├── iterator.rs\n│   │   │   • Implements a type‑aware PrefixIterator on a RocksDB iterator.\n│   │   ├── mod.rs\n│   │   │   • Re‑exports DB submodules and provides common RocksDB persistence helpers.\n│   │   └── typed_db.rs\n│   │       • Wraps DB access with typed key–value storage.\n│   ├── lib.rs\n│   │   • Main entry point; exposes cryptographic types, AWS and DB utilities, and on‑chain primitives.\n│   ├── models/\n│   │   ├── home.rs\n│   │   │   • Implements Home‑chain logic (dispatching messages, producing updates, state transitions).\n│   │   └── replica.rs\n│   │       • Implements Replica‑chain abstractions, including proof submission and update state transitions.\n│   ├── test_output.rs\n│   │   • Functions to generate JSON test files for integration tests.\n│   ├── test_utils.rs\n│   │   • Helper functions for setting up merkle tree tests, locating fixtures, etc.\n│   ├── traits/\n│   │   ├── encode.rs\n│   │   │   • Declares the Encode/Decode traits for canonical (de)serialization.\n│   │   ├── home.rs\n│   │   │   • Defines interfaces for on‑chain Home contract interactions.\n│   │   ├── indexer.rs\n│   │   │   • Traits for chain event indexing (fetching block numbers, sorted updates).\n│   │   ├── replica.rs\n│   │   │   • Declares the Replica trait and supported message statuses.\n│   │   ├── signer.rs\n│   │   │   • Extends ethers’ Signer with additional helper methods.\n│   │   ├── xapp.rs\n│   │   │   • Defines the ConnectionManager trait for cross‑chain connection management.\n│   │   └── mod.rs\n│   │       • Umbrella module for all traits and shared type aliases.\n│   └── utils.rs\n│       • Exposes helper functions (e.g. computing home_domain_hash, packing destination and nonce).\n```\n*Overall Role:* Forms the core engine that combines cryptographic operations, on‑chain abstraction (via traits and models), persistent DB management, and integrations with external services (AWS). This module underpins the high‑level behaviors of updates, message submissions, and proof verifications.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### agents\n```\nagents/\n├── kathy/\n│   └── src/\n│       ├── main.rs\n│       │   • Entry point: setups logging/tracing, loads configuration and instantiates the Kathy agent.\n│       ├── kathy.rs\n│       │   • Implements the core functionality for generating and dispatching “chatty” messages.\n│       └── settings.rs\n│           • Loads and validates Kathy‑specific configuration via Nomad’s custom config system.\n├── watcher/\n│   └── src/\n│       ├── main.rs\n│       │   • Sets up error reporting, loads watcher configuration, and starts the Watcher service.\n│       ├── watcher.rs\n│       │   • Core logic, including:\n│       │       – ContractWatcher: polling Home/Replica for signed updates.\n│       │       – HistorySync: back‐scanning update history.\n│       │       – UpdateHandler: verifying updates against the DB and triggering fraud notifications.\n│       └── settings.rs\n│           • Provides configuration options for polling intervals, connection manager info, and attestation signers.\n├── processor/\n│   └── src/\n│       ├── main.rs\n│       │   • Initializes tracing, loads settings, and starts the message processing loop.\n│       ├── processor.rs\n│       │   • Implements the processing loop:\n│       │       – Fetches the next message by nonce.\n│       │       – Checks allow/deny lists.\n│       │       – Retrieves Merkle proofs (via ProverSync).\n│       │       – Dispatches on‑chain transactions.\n│       ├── prover_sync.rs\n│       │   • Keeps the local Merkle tree in sync with confirmed chain updates.\n│       ├── push.rs\n│       │   • Serializes and uploads proofs to an S3 bucket for archival or later verification.\n│       └── settings.rs\n│           • Provides processor‑specific parameters (e.g. polling intervals, sender filters, S3 settings).\n├── updater/\n│   └── src/\n│       ├── main.rs\n│       │   • Sets up configuration and tracing, then starts the Updater service.\n│       ├── updater.rs\n│       │   • Defines the overall updater structure, coordinating update production and submission.\n│       ├── produce.rs\n│       │   • Polls the home for a “suggested update” and produces a signed update.\n│       ├── submit.rs\n│       │   • Retrieves produced updates and submits them to the home chain (waiting for finality).\n│       └── settings.rs\n│           • Gathers chain timings, signer credentials, and attestation details.\n└── relayer/\n    └── src/\n        ├── main.rs\n        │   • Entry point that sets up logging/tracing and loads relayer configuration.\n        ├── relayer.rs\n        │   • Core logic that:\n        │         – Periodically polls the home chain for signed updates.\n        │         – Uses a semaphore to ensure only one relay transaction is active at a time.\n        │         – Forwards updates to the replica.\n        └── settings.rs\n            • Defines relayer‑specific parameters (polling intervals, chain IDs, etc.).\n```\n*Overall Role:* Each agent operates as an independent service with a dedicated responsibility. Their interactions implement the optimistic security model—updater attests updates; relayer forwards them; processor proves inclusion; and watcher safeguards against fraud. “Kathy” serves as a demonstrative messaging agent.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### nomad-base\n```\nnomad-base/\n├── bin/\n│   ├── example.rs\n│   │   • Demonstrates instantiation and running of an agent using the NomadAgent trait.\n│   └── secrets_template.rs\n│         • Generates a JSON template for configuring secret parameters (RPC URLs, keys, etc.).\n├── tests/\n│   └── signer_integration.rs\n│         • Integration tests ensuring that attestation and TX signer functionality works correctly.\n└── src/\n     ├── agent.rs\n     │     • Defines the AgentCore struct (aggregating home/replica handles, DB, metrics, settings)\n     │       and the NomadAgent trait used by all agents.\n     ├── contract_sync/\n     │     ├── metrics.rs\n     │     │     • Implements Prometheus metrics for contract syncing tasks.\n     │     ├── mod.rs\n     │     │     • Implements ContractSync: polls on‑chain events via indexers and writes to NomadDB.\n     │     └── schema.rs\n     │           • Declares traits and key names for persisting “last processed block” metadata.\n     ├── error.rs\n     │     • Defines unified error types (mapping chain‑specific errors, database errors, etc.).\n     ├── home.rs\n     │     • Implements a caching Home contract wrapper that supports local caching and DB syncing.\n     ├── indexer.rs\n     │     • Provides abstractions over chain indexers to fetch sorted updates and messages.\n     ├── lib.rs\n     │     • Re-exports modules such as agent, settings, metrics, nomad_db, home, replica, contract_sync, and xapp.\n     ├── macors.rs\n     │     • Contains helper macros (cancel_task, decl_agent, decl_channel) to reduce boilerplate.\n     ├── metrics.rs\n     │     • Implements core Prometheus metrics for agents (transaction counters, RPC latencies, etc.).\n     ├── nomad_db.rs\n     │     • Provides a typed key/value wrapper around a persistent DB (e.g. RocksDB).\n     ├── replica.rs\n     │     • Implements a caching Replica that wraps a remote chain replica contract.\n     ├── submitter.rs\n     │     • Contains helper functions for transaction submission.\n     ├── xapp.rs\n     │     • Implements the connection manager (XApp) that administers replica enrollment and watcher permissions.\n     └── settings/\n           ├── chains.rs\n           │     • Defines ChainSetup structure capturing chain parameters and helper functions to build Home/Replica objects.\n           ├── macros.rs\n           │     • Offers macros (decl_settings!) for declaring agent‑specific configuration blocks.\n           ├── mod.rs\n           │     • Loads and validates comprehensive configuration (DB paths, metrics ports, chain configurations, logging, etc.).\n           └── trace/\n                 ├── fmt.rs\n                 │     • Provides formatting options for tracing logs (full, pretty, compact, JSON).\n                 ├── mod.rs\n                 │     • Aggregates tracing sub‑modules.\n                 └── span_metrics.rs\n                       • Implements a tracing_subscriber layer for recording span lifetimes as Prometheus metrics.\n```\n*Overall Role:* Serves as the base framework for all Nomad agents. It defines shared traits, error types, persistence mechanisms, metrics collections, and connection management that agents rely on to interact with on‑chain contracts and maintain cross‑chain state.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### accumulator\n```\naccumulator/\n└── src/\n    ├── error.rs\n    │   • Defines custom error types (ProvingError, VerifyingError, IngestionError) for Merkle tree operations.\n    ├── full.rs\n    │   • Implements a “full” sparse Merkle tree with variants (Leaf, Node, Zero), functions to create the tree, push leaves,\n    │       and generate inclusion proofs.\n    ├── lib.rs\n    │   • Main entry point that re‑exports full, light, tree, proof, error, wasm, and utils.\n    │   • Defines constants (TREE_DEPTH) and type aliases (NomadTree, NomadProof) as well as traits for Merkle operations.\n    ├── light.rs\n    │   • Implements a lightweight (incremental) Merkle tree for on‑chain verification with fixed‑size branch arrays and helper methods.\n    ├── proof.rs\n    │   • Defines the Proof struct that holds a leaf’s hash, index, and branch (sibling hashes) plus methods to compute a root.\n    ├── tree.rs\n    │   • Provides a high‑level wrapper over the full Merkle tree; supports conversion from iterators and generating proofs.\n    ├── wasm.rs\n    │   • Exposes WebAssembly bindings using wasm-bindgen; for each supported tree depth exports types (e.g. Tree32, Proof32) for JS/TS consumption.\n    └── utils.rs\n        • Contains cryptographic helper functions (hash, hash_concat) as well as max_leaves utility for computing capacity.\n```\n*Overall Role:* Implements the cryptographic primitives (Merkle trees and proofs) that underpin message inclusion verification. It supports both off‑chain rigorous proof generation (“full”) and on‑chain verification (“light”) modes, with WASM support for cross-platform interfacing.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n### chains\n```\nchains/\n├── nomad‑substrate/\n│   └── src/\n│       ├── client.rs\n│       │   • Implements NomadOnlineClient to wrap subxt’s OnlineClient, with helper functions (block numbers, storage queries).\n│       ├── decodings.rs\n│       │   • Contains types and wrappers to decode SCALE‑encoded Substrate data.\n│       ├── error.rs\n│       │   • Defines SubstrateError to wrap errors from subxt and SCALE deserialization.\n│       ├── home.rs\n│       │   • Implements the Home interface for Substrate, including state retrieval and update production.\n│       ├── macros.rs\n│       │   • Provides substrate‑specific helper macros (e.g. report_tx!).\n│       ├── replica.rs\n│       │   • Implements the Replica functionality for Substrate–based chains.\n│       ├── signer.rs\n│       │   • Provides substrate‑specific signer implementations (from hex keys to subxt signers).\n│       ├── utils.rs\n│       │   • Miscellaneous helper functions (e.g. formatting update values for SCALE).\n│       ├── xapp.rs\n│       │   • Implements the connection manager for Substrate (replica enrollment, watcher permissions).\n│       └── configs/\n│           ├── mod.rs\n│           └── avail.rs\n│               • Provides configuration and implementations for the Avail chain.\n└── nomad‑ethereum/\n    ├── build.rs\n    │   • A build script that reads ABI files and generates Rust bindings using ethers Abigen.\n    └── src/\n        ├── replica.rs\n        │   • Implements Ethereum’s Replica functionality using generated contract bindings.\n        ├── home.rs\n        │   • Implements Ethereum’s Home interface (dispatching messages, querying nonces, producing updates).\n        ├── error.rs\n        │   • Defines EthereumError covering provider, contract, and middleware errors.\n        ├── gelato.rs\n        │   • Implements integration with Gelato’s relay service for transaction submission.\n        ├── gas.rs\n        │   • Provides middleware to adjust gas prices automatically.\n        ├── lib.rs\n        │   • Main library entry; re‑exports Ethereum modules and ties components together.\n        ├── retrying.rs\n        │   • Wraps an ethers JSON‑RPC client to perform exponential backoff for failed requests.\n        ├── xapp.rs\n        │   • Implements the XApp connection manager for replica enrollment and administrative tasks.\n        ├── signer.rs\n        │   • Implements Ethereum signer types (Local, AWS‑based) and conversion from config.\n        ├── submitter.rs\n        │   • Provides abstractions to submit transactions either locally or via Gelato relay.\n        ├── macros.rs\n        │   • Contains helper macros for creating boxed contract handles and reporting transactions.\n        └── utils.rs\n            • Provides utility functions converting Ethereum transaction receipts to standardized outcomes.\n```\n*Overall Role:* Implements chain‑specific interfaces that map the Nomad protocol to blockchain operations. Both modules implement Home/Replica, signing, connection management, and transaction submission—allowing higher‑level agents to work in a chain‑agnostic manner. Changes to these modules affect how messages are read, attested, and processed on Ethereum or Substrate networks.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n## 3. How Components Interact\n\nNomad’s architecture is built on loosely coupled, modular components that interact as follows:\n\n• **Configuration & Types:**  \n  All services (agents, chain connectors, base framework) load their settings from the configuration module. The nomad‑types crate ensures that identifiers (such as addresses and chain IDs) are consistent system‑wide, while environment override traits allow runtime customization.\n\n• **Agent Interactions:**  \n  – The **Updater** monitors the home chain’s state and, when conditions are met, produces a signed update to the contract.  \n  – The **Relayer** continuously polls the home chain for these attested updates. When found, it forwards them to the destination chain’s replica.  \n  – The **Processor** uses a locally maintained Merkle accumulator (from the accumulator module) to generate or verify inclusion proofs for messages, then submits them on‑chain after confirming that the proof’s root matches what the replica expects.  \n  – The **Watcher** monitors update histories and state changes both in the home and replica contracts to detect any double updates or fraud. In such cases, it interrupts processing and signals failure notifications.  \n  – The **Kathy** agent simulates message sending, primarily for demonstration and testing, feeding messages into the system.\n\n• **Chain Connectivity:**  \n  The chain-specific modules in **chains/** interface with live blockchain networks. They provide smart contract bindings (for Ethereum), Substrate client interactions, and standardized methods to query state, sign transactions, and submit updates. The chain modules also support middleware (e.g. gas adjustment on Ethereum, retry logic) that help ensure reliable operations.\n\n• **Data Integrity & Proofs:**  \n  The **accumulator** module implements both a full Merkle tree (for off‑chain, rigorous proof generation) and a lightweight version (for efficient on‑chain verification). Agents (especially the Processor) depend on these proofs to verify that messages are correctly included in the off‑chain state kept by the Home contract.\n\n• **Persistent Storage & Metrics:**  \n  The **nomad-base** package provides an abstraction over persistent storage (NomadDB) and synchronizes contract events via the ContractSync module. In addition, it employs Prometheus-based metrics and tracing layers to expose runtime statistics and error data—ensuring operational robustness.\n\n• **Testing & Mocks:**  \n  The **nomad-test** module offers mocks for on‑chain contracts and utility functions so that developer tests and CI systems can simulate various scenarios without reliance on an actual chain. This enables thorough testing of update logic, proof processing, and error handling in controlled conditions.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n## 4. Navigating the Repository\n\nA developer or operator can use the following guidelines:  \n• To modify how the system’s configuration works (from agent settings to chain deployment details), inspect the **configuration/** directory.  \n• Changes to core types (identifiers, numeric deserialization, error handling) impact **nomad-types/**.  \n• To experiment with proof generation or adjust Merkle tree logic, review the **accumulator/** module.  \n• For testing, enhanced mocks, and integration testing utilities, **nomad-test/** is the central hub.  \n• Any modifications to the low-level protocol (update/dispatch logic, AWS integration, DB persistence) should begin from **nomad-core/**.  \n• Agent-specific issues (whether updater, relayer, processor, watcher, or kathy) should be addressed in the **agents/** directory—each of which is a standalone Rust binary with its own settings and main entrypoint.  \n• Finally, improvements or fixes to the shared base functionality, metrics, or connection management are located in **nomad-base/**, which ties together the various services.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\n## 5. Summary\n\nNomad’s architecture is a layered, modular design that separates configuration, core protocol logic, chain interactions, agent responsibilities, cryptographic inclusion proofs, and testing utilities into discrete components. They interact through clearly defined interfaces: configuration and types govern initialization; the core and base modules provide essential building blocks for blockchain interfacing and state management; while dedicated agents perform runtime services following the secure optimistic model. This separation of concerns facilitates both robust operation and ease of maintenance/extension across different chains and deployment scenarios.\n\nThis document should serve as your roadmap for navigating the repository and understanding where to look when addressing tasks or diagnosing issues within the Nomad cross‑chain bridge protocol.\n\n––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––\nEnd of Document.